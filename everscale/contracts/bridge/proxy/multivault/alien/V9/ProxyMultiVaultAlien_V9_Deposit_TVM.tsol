// SPDX-License-Identifier: UNLICENSED
pragma ever-solidity >= 0.62.0;

import "../../../../interfaces/event-contracts/ITvmTvmEvent.tsol";
import "../../../../interfaces/proxy/ITvmTvmProxyExtended.tsol";
import "../../../../libraries/EventContractNonce.tsol";

import "./ProxyMultiVaultAlien_V9_Fees.tsol";

abstract contract ProxyMultiVaultAlien_V9_Deposit_TVM is
    ProxyMultiVaultAlien_V9_Fees,
    ITvmTvmProxyExtended
{
    function onTVMEventConfirmedExtended(
        ITvmTvmEvent.TvmTvmEventInitData eventInitData,
        TvmCell meta,
        address remainingGasTo
    ) external override reserveAtLeastTargetBalance {
        require(
            _isArrayContainsAddress(tvmConfiguration.incomingConfigurations, msg.sender),
            ErrorCodes.NOT_TVM_CONFIG
        );

        (
            address token,
            uint128 amount,
            address recipient,
            TvmCell payload,
            address nativeProxyTokenWallet
        ) = abi.decode(
            meta,
            (address, uint128, address, TvmCell, address)
        );

        // accumulate fee
        uint128 fee = _calculateFees(amount);
        _accumulateFee(fee, token);

        if (nativeProxyTokenWallet.value != 0) {
            TvmCell _meta = abi.encode(
                nativeProxyTokenWallet,
                amount - fee,
                recipient,
                payload
            );

            ITvmTvmProxyExtended(proxyMultiVaultNative).onTVMEventConfirmedExtended{
                    flag: MsgFlag.ALL_NOT_RESERVED
                }(eventInitData, _meta, remainingGasTo);

            return;
        }

        uint32 nonce = EventContractNonce._calculateNonce(eventInitData);

        _mintTokens(
            token,
            amount - fee,
            recipient,
            remainingGasTo,
            abi.encode(nonce, payload)
        );
    }
}
