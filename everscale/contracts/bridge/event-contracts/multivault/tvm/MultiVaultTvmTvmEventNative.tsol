pragma ever-solidity >= 0.62.0;
pragma AbiHeader time;
pragma AbiHeader pubkey;
pragma AbiHeader expire;

import "ton-eth-bridge-token-contracts/contracts/interfaces/ITokenRoot.tsol";

import "./../../../interfaces/event-contracts/multivault/tvm/IMultiVaultTvmTvmEventNative.tsol";
import "./../../../interfaces/event-configuration-contracts/ITvmTvmEventConfiguration.tsol";
import "./../../../interfaces/proxy/ITvmTvmProxyExtended.tsol";
import "./../../../interfaces/trustless-verifier/ITrustlessVerifier.tsol";
import "./../../../interfaces/trustless-verifier/IOnTrustlessVerify.tsol";

import "./../../base/tvm/TvmTvmBaseEvent.tsol";


contract MultiVaultTvmTvmEventNative is
    TvmTvmBaseEvent,
    IMultiVaultTvmTvmEventNative,
    IOnTrustlessVerify
{
    address public token;
    uint128 public amount;
    address public recipient;

    uint public value;
    uint public expected_gas;
    TvmCell public payload;

    // Derived fields
    address public proxy;
    address public tokenWallet;

    bool setupFinished;

    constructor(
        address _initializer,
        TvmCell _meta,
        address _transactionChecker,
        TvmCell _eventBody
    ) TvmTvmBaseEvent(_initializer, _meta,  _transactionChecker, _eventBody) public {}

    function onInit() override internal {
        status = Status.Initializing;
    }

    function processProof(ITvmTvmEvent.TvmTvmEventVoteData _eventVoteData) override external {
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        TvmCell data = eventBody.toSlice().loadRef();
        (
            /*chain_id*/,
            token,
            amount,
            recipient,

            value,
            expected_gas,
            /*remaining_gas_to*/,
            /*sender*/,
            payload
        ) = abi.decode(
            data,
            (
                uint256, address, uint128, address,
                uint256, uint256, address, address,
                TvmCell
            )
        );

        // return gas in case event contract is less than required
        if (address(this).balance < expected_gas) {
            initializer.transfer({
                value: 0,
                bounce: false,
                flag: MsgFlag.ALL_NOT_RESERVED
            });

            return;
        }

        status = Status.Pending;

        // todo call transactionChecker to validate eventVoteData (callback onTransactionCheck)

        uint256 txHash = 0; // todo use BocDecoder
        ITrustlessVerifier(transactionChecker)
            .verifyTx{
                value: gasToValue(Gas.VERIFY_TRANSACTION_GAS, address(this).wid),
                flag: MsgFlag.SENDER_PAYS_FEES
            }(txHash, _eventVoteData.txBlockProof);

        ITvmTvmEventConfiguration(eventInitData.configuration).getDetails{
                value: gasToValue(Gas.REQUEST_CONFIGURATION_DETAILS_GAS, address(this).wid),
                callback: MultiVaultTvmTvmEventNative.receiveConfigurationDetails
            }();
    }

    function onTrustlessVerify(bool success) external override {
        require(msg.sender == transactionChecker, ErrorCodes.SENDER_NOT_TX_CHECKER);

        if (success) {
            status = Status.Confirmed;
            onConfirm();
        }
    }

    function receiveConfigurationDetails(
        IBasicEventConfiguration.BasicConfiguration,
        ITvmTvmEventConfiguration.TvmTvmEventConfiguration _networkConfiguration,
        TvmCell
    ) external override {
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        proxy = _networkConfiguration.proxy;

        ITokenRoot(token).walletOf{
            value: gasToValue(Gas.GET_TOKEN_DATA_GAS, address(this).wid),
            callback: MultiVaultTvmTvmEventNative.receiveProxyTokenWallet
        }(proxy);
    }

    function receiveProxyTokenWallet(
        address tokenWallet_
    ) external override {
        require(msg.sender == token, ErrorCodes.SENDER_NOT_ROOT);

        tokenWallet = tokenWallet_;

        setupFinished = true;
        onConfirm();
    }

    function getDecodedData() external override responsible returns(
        address token_,
        uint128 amount_,
        address recipient_,
        uint value_,
        uint expected_gas_,
        TvmCell payload_,
        address proxy_,
        address tokenWallet_
    ) {
        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS}(
            token,
            amount,
            recipient,
            value,
            expected_gas,
            payload,
            proxy,
            tokenWallet
        );
    }

    function onConfirm() internal override {
        if (status == Status.Confirmed && setupFinished) {
            TvmCell metaData = abi.encode(
                tokenWallet,
                amount,
                recipient,
                payload
            );

            ITvmTvmProxyExtended(eventInitData.configuration).onTVMEventConfirmedExtended{
                flag: MsgFlag.ALL_NOT_RESERVED
            }(eventInitData, metaData, initializer);
        }
    }
}
