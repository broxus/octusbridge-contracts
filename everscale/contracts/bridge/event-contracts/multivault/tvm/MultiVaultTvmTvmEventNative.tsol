pragma ever-solidity >= 0.62.0;

pragma AbiHeader pubkey;
pragma AbiHeader expire;

import "ton-eth-bridge-token-contracts/contracts/interfaces/ITokenRoot.tsol";
import "ton-eth-bridge-token-contracts/contracts/interfaces/ITokenWallet.tsol";
import "ton-eth-bridge-token-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";

import "./../../../interfaces/event-contracts/multivault/tvm/IMultiVaultTvmTvmEventNative.tsol";
import "./../../../interfaces/event-configuration-contracts/ITvmTvmEventConfiguration.tsol";
import "./../../../interfaces/proxy/ITvmTvmProxyExtended.tsol";
import "./../../../interfaces/proxy/ITvmEventCancelled.tsol";
import "./../../../interfaces/trustless-verifier/ITrustlessVerifier.tsol";
import "./../../../interfaces/trustless-verifier/IOnTrustlessVerify.tsol";
import "./../../../libraries/BocDecoder.tsol";

import "./../../base/tvm/TvmTvmBaseEvent.tsol";


contract MultiVaultTvmTvmEventNative is
    TvmTvmBaseEvent,
    IMultiVaultTvmTvmEventNative,
    IOnTrustlessVerify,
    IAcceptTokensTransferCallback
{
    address public token;
    string public name;
    string public symbol;
    uint8 public decimals;
    address public proxyTokenWallet;

    uint128 public amount;
    address public recipient;

    uint public value;
    uint128 public expected_gas;
    optional(TvmCell) public payload;

    // Derived fields
    address public proxy;

    bool setupFinished;

    uint128 public reward;
    address public eventTokenWallet;

    constructor(
        address _initializer,
        TvmCell _meta,
        address _transactionChecker,
        TvmCell _eventBody,
        uint128 _eventInitialBalance
    ) TvmTvmBaseEvent(_initializer, _meta,  _transactionChecker, _eventBody, _eventInitialBalance) {}

    function onInit() override internal {
        status = Status.Initializing;
    }

    function processProof(ITvmTvmEvent.TvmTvmEventVoteData _eventVoteData) override external {
        bool isValidStatus = status == Status.Initializing || status == Status.Pending || status == Status.Verified;

        require(isValidStatus, ErrorCodes.EVENT_NOT_INITIALIZING);
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        optional(TvmCell) data = eventBody.toSlice().load(optional(TvmCell));
        (
            /*functionId*/,
            /*chain_id*/,

            token,
            name,
            symbol,
            decimals,
            proxyTokenWallet,

            /*sender*/,
            recipient,
            amount,

            value,
            expected_gas,
            /*remaining_gas_to*/,

            payload
        ) = abi.decode(data.get(), (
            uint32, int32,
            address, string, string, uint8, address,
            address, address, uint128,
            uint256, uint128, address,
            optional(TvmCell)
        ));


        // return gas in case event contract is less than required
        if (address(this).balance < expected_gas + eventInitialBalance) {
            initializer.transfer({
                value: 0,
                bounce: false,
                flag: MsgFlag.ALL_NOT_RESERVED
            });

            return;
        }

        if (status == Status.Initializing || status == Status.Pending) {
            status = Status.Pending;

            (
                uint256 accountAddr,
                uint64 lt,
                ,
                ,
                uint256 hash
            ) = BocDecoder.decodeTransactionShort(_eventVoteData.txProof);

            TvmCell txProof = abi.encode(
                accountAddr,
                lt,
                hash
            );

            ITrustlessVerifier(transactionChecker)
                .verifyTx{
                    value: gasToValue(Gas.VERIFY_TRANSACTION_GAS, address(this).wid),
                    flag: MsgFlag.SENDER_PAYS_FEES
                }(_eventVoteData.txBlockProof, txProof);
        }

        ITvmTvmEventConfiguration(eventInitData.configuration)
            .getDetails{
                value: gasToValue(Gas.REQUEST_CONFIGURATION_DETAILS_GAS, address(this).wid),
                callback: MultiVaultTvmTvmEventNative.receiveConfigurationDetails
            }();
    }

    function onTrustlessVerify(bool success, uint256 /*txHash*/) external functionID(0x756adff1) override {
        require(msg.sender == transactionChecker, ErrorCodes.SENDER_NOT_TX_CHECKER);
        require(status == Status.Pending, ErrorCodes.EVENT_NOT_PENDING);

        if (success) {
            status = Status.Verified;
            onConfirm();
        }
    }

    function receiveConfigurationDetails(
        IBasicEventConfiguration.BasicConfiguration,
        ITvmTvmEventConfiguration.TvmTvmEventConfiguration _networkConfiguration,
        TvmCell
    ) external override {
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        proxy = _networkConfiguration.proxy;

        setupFinished = true;
        onConfirm();
    }

    function getDecodedData() external override responsible returns(
        address token_,
        string name_,
        string symbol_,
        uint8 decimals_,
        uint128 amount_,
        address recipient_,
        uint value_,
        uint128 expected_gas_,
        optional(TvmCell) payload_,
        address proxy_,
        address tokenWallet_
    ) {
        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS}(
            token,
            name,
            symbol,
            decimals,
            amount,
            recipient,
            value,
            expected_gas,
            payload,
            proxy,
            proxyTokenWallet
        );
    }

    function onConfirm() internal override {
        if (status == Status.Verified && setupFinished) {
            status = Status.Confirmed;

            emit Confirmed();

            TvmCell metaData = abi.encode(
                proxyTokenWallet,
                amount,
                recipient,
                payload,
                address(this),
                expected_gas
            );

            ITvmTvmProxyExtended(eventInitData.configuration).onTVMEventConfirmedExtended{
                flag: MsgFlag.ALL_NOT_RESERVED
            }(eventInitData, metaData, initializer);
        }
    }

    function notEnoughLiquidity() external override {
        require(msg.sender == proxy, ErrorCodes.SENDER_NOT_PROXY);

        status = Status.NotEnoughLiquidity;
        emit NotEnoughLiquidity();

        initializer.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
            bounce: false
        });
    }

    function cancel(
        address _newRecipient,
        address _remainingGasTo,
        uint128 _expectedGas,
        optional(TvmCell) _eventPayload
    ) external {
        require(status == Status.NotEnoughLiquidity, ErrorCodes.WRONG_STATUS);
        require(msg.sender == recipient, ErrorCodes.SENDER_NOT_RECIPIENT);

        status = Status.Cancelled;
        emit Cancelled();

        TvmCell transferData = abi.encode(
            _newRecipient,
            eventInitData.chainId,
            name,
            symbol,
            decimals,
            _expectedGas,
            _eventPayload
        );

        TvmCell withdrawPayload = abi.encode(
            token,
            amount,
            recipient,
            _remainingGasTo,
            proxyTokenWallet,
            transferData
        );

        ITvmEventCancelled(eventInitData.configuration)
            .onTVMEventCancelled{
                flag: MsgFlag.ALL_NOT_RESERVED
            }(eventInitData, withdrawPayload);
    }

    function requestLiquidity(uint128 _reward) external {
        require(status == Status.NotEnoughLiquidity, ErrorCodes.WRONG_STATUS);
        require(msg.sender == recipient, ErrorCodes.SENDER_NOT_RECIPIENT);
        require(reward <= amount, ErrorCodes.WRONG_REWARD);

        status = Status.LiquidityRequested;
        reward = _reward;

        emit LiquidityRequested(reward);

        ITokenRoot(token).walletOf{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED,
            callback: MultiVaultTvmTvmEventNative.receiveProxyTokenWallet
        }(address(this));
    }

    function receiveProxyTokenWallet(
        address tokenWallet_
    ) external override {
        require(msg.sender == token, ErrorCodes.SENDER_NOT_ROOT);

        eventTokenWallet = tokenWallet_;

        recipient.transfer({
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
            bounce: false
        });
    }

    function onAcceptTokensTransfer(
        address /*_tokenRoot*/,
        uint128 _amount,
        address _sender,
        address /*senderWallet*/,
        address _remainingGasTo,
        TvmCell _payload
    ) override external {
        require(msg.sender == eventTokenWallet, ErrorCodes.SENDER_NOT_TOKEN_WALLET);

        // return tokens to sender in case of wrong amount or incorrect status
        if (status != Status.LiquidityRequested || _amount < amount - reward) {
            TvmCell empty;

            ITokenWallet(eventTokenWallet).transfer{
                value: 0,
                bounce: false,
                flag: MsgFlag.ALL_NOT_RESERVED
            }(
                _amount,
                _sender,
                Gas.getDeployTokenWalletValue(),
                _remainingGasTo,
                false,
                empty
            );

            return;
        }

        status = Status.LiquidityProvided;
        emit LiquidityProvided(_sender);

        // send tokens to original recipient
        ITokenWallet(eventTokenWallet).transfer{
            value: 0,
            bounce: false,
            flag: MsgFlag.ALL_NOT_RESERVED
        }(
            _amount,
            recipient,
            Gas.getDeployTokenWalletValue(),
            _remainingGasTo,
            payload.hasValue() ? true : false,
            payload.get()
        );

        // emit withdraw event to original chainId
        (
            address newRecipient,
            address remainingGasTo,
            uint128 expectedGas,
            optional(TvmCell) eventPayload
        ) = abi.decode(_payload, (
            address,
            address,
            uint128,
            optional(TvmCell)
        ));

        TvmCell transferData = abi.encode(
            newRecipient,
            eventInitData.chainId,
            name,
            symbol,
            decimals,
            expectedGas,
            eventPayload
        );

        TvmCell withdrawPayload = abi.encode(
            token,
            amount,
            _sender,
            remainingGasTo,
            proxyTokenWallet,
            transferData
        );

        ITvmEventCancelled(eventInitData.configuration)
            .onTVMEventCancelled{
                flag: MsgFlag.ALL_NOT_RESERVED
            }(eventInitData, withdrawPayload);
    }
}
