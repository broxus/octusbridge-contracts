pragma ever-solidity >= 0.62.0;

pragma AbiHeader pubkey;
pragma AbiHeader expire;

import "ton-eth-bridge-token-contracts/contracts/interfaces/ITokenRoot.tsol";

import "./../../../interfaces/event-contracts/multivault/tvm/IMultiVaultTvmTvmEventNative.tsol";
import "./../../../interfaces/event-configuration-contracts/ITvmTvmEventConfiguration.tsol";
import "./../../../interfaces/proxy/ITvmTvmProxyExtended.tsol";
import "./../../../interfaces/trustless-verifier/ITrustlessVerifier.tsol";
import "./../../../interfaces/trustless-verifier/IOnTrustlessVerify.tsol";
import "./../../../libraries/BocDecoder.tsol";

import "./../../base/tvm/TvmTvmBaseEvent.tsol";


contract MultiVaultTvmTvmEventNative is
    TvmTvmBaseEvent,
    IMultiVaultTvmTvmEventNative,
    IOnTrustlessVerify
{
    address public token;
    string public name;
    string public symbol;
    uint8 public decimals;
    address public proxyTokenWallet;

    uint128 public amount;
    address public recipient;

    uint public value;
    uint128 public expected_gas;
    optional(TvmCell) public payload;

    // Derived fields
    address public proxy;

    bool setupFinished;

    constructor(
        address _initializer,
        TvmCell _meta,
        address _transactionChecker,
        TvmCell _eventBody
    ) TvmTvmBaseEvent(_initializer, _meta,  _transactionChecker, _eventBody) {}

    function onInit() override internal {
        status = Status.Initializing;
    }

    function processProof(ITvmTvmEvent.TvmTvmEventVoteData _eventVoteData) override external {
        require(status != Status.Confirmed, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        optional(TvmCell) data = eventBody.toSlice().load(optional(TvmCell));
        (
            /*functionId*/,
            /*chain_id*/,

            token,
            name,
            symbol,
            decimals,
            proxyTokenWallet,

            /*sender*/,
            recipient,
            amount,

            value,
            expected_gas,
            /*remaining_gas_to*/,

            payload
        ) = abi.decode(data.get(), (
            uint32, int32,
            address, string, string, uint8, address,
            address, address, uint128,
            uint256, uint128, address,
            optional(TvmCell)
        ));


        // return gas in case event contract is less than required
        if (address(this).balance < expected_gas) {
            initializer.transfer({
                value: 0,
                bounce: false,
                flag: MsgFlag.ALL_NOT_RESERVED
            });

            return;
        }

        status = Status.Pending;

        (uint256 accountAddr, uint64 lt, , , uint256 hash) = BocDecoder.decodeTransactionShort(_eventVoteData.txProof);

        TvmCell txProof = abi.encode(
            accountAddr,
            lt,
            hash
        );

        ITrustlessVerifier(transactionChecker)
            .verifyTx{
                value: gasToValue(Gas.VERIFY_TRANSACTION_GAS, address(this).wid),
                flag: MsgFlag.SENDER_PAYS_FEES
            }(_eventVoteData.txBlockProof, txProof);

        ITvmTvmEventConfiguration(eventInitData.configuration)
            .getDetails{
                value: gasToValue(Gas.REQUEST_CONFIGURATION_DETAILS_GAS, address(this).wid),
                callback: MultiVaultTvmTvmEventNative.receiveConfigurationDetails
            }();
    }

    function onTrustlessVerify(bool success, uint256 /*txHash*/) external functionID(0x756adff1) override {
        require(msg.sender == transactionChecker, ErrorCodes.SENDER_NOT_TX_CHECKER);

        if (success) {
            status = Status.Confirmed;
            onConfirm();
        }
    }

    function receiveConfigurationDetails(
        IBasicEventConfiguration.BasicConfiguration,
        ITvmTvmEventConfiguration.TvmTvmEventConfiguration _networkConfiguration,
        TvmCell
    ) external override {
        require(msg.sender == eventInitData.configuration, ErrorCodes.SENDER_NOT_EVENT_CONFIGURATION);

        proxy = _networkConfiguration.proxy;

        setupFinished = true;
        onConfirm();
    }

    function getDecodedData() external override responsible returns(
        address token_,
        string name_,
        string symbol_,
        uint8 decimals_,
        uint128 amount_,
        address recipient_,
        uint value_,
        uint128 expected_gas_,
        optional(TvmCell) payload_,
        address proxy_,
        address tokenWallet_
    ) {
        return {value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS}(
            token,
            name,
            symbol,
            decimals,
            amount,
            recipient,
            value,
            expected_gas,
            payload,
            proxy,
            proxyTokenWallet
        );
    }

    function onConfirm() internal override {
        if (status == Status.Confirmed && setupFinished) {
            emit Confirmed();

            TvmCell metaData = abi.encode(
                proxyTokenWallet,
                amount,
                recipient,
                payload
            );

            ITvmTvmProxyExtended(eventInitData.configuration).onTVMEventConfirmedExtended{
                flag: MsgFlag.ALL_NOT_RESERVED
            }(eventInitData, metaData, initializer);
        }
    }
}
